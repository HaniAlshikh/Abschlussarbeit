% @author Hani Alshikh
%
\chapter{Audit Browser}

Wenn mehrere Teil-Kapitel zu strukturieren sind: Schreiben Sie zu jedem Teil-Kapitel eine Ein- leitung ("Hier wird die folgende Fragestellung untersucht...") und eine Ausleitung ("Hiermit ist erreicht: ... Die folgenden Probleme sind aber noch offen:...").

Process Discovery \cite{5427384}
By analyzing frequent patterns, process mining techniques can extract from event logs models that describe the processes at hand. For example, the Alpha process mining algorithm can automatically extract a Petri net that concisely models behavior in the event log. This gives the auditor an unbiased view of what has actually happened.

Conformance Checking
An auditor can use an a priori process model to check if reality, as recorded in the event log, conforms to the model and vice versa. For example, a model may indicate that purchase orders exceeding one million euros require two checks. Auditors can use conformance checking to detect deviations, locate and explain them, and measure their severity (A. Rozinat and W.M.P. van der Aalst, “Conformance Checking of Processes Based on Monitoring Real Behavior,” Information Systems, vol. 33, no. 1, 2008, pp. 64–95).

Toward Operational Support
Although process mining has traditionally focused on offline analysis and is seldom used for operational decision support, it can consider running-process instances and compare them with models based on historic data or business rules (W. M. P. van der Aalst, M. Pesic, and M. Song, “Beyond Process Mining: From the Past to Present and Future,” tech. report BPM-09-18 BPMcenter.org, 2009). For example, an auditor can “replay” a running case on the process model in real time and check whether the observed behavior fits. The moment the case deviates, the auditor can alert an appropriate actor.

Auditors can also use a process model based on historic data to make predictions about running cases—for example, to estimate the remaining processing time and a particular outcome's probability—or provide recommendations, such as an activity that will minimize the expected costs and completion time.

\section{Requirements}

% Anforderungen aufgrund von Gesprächen mit dem Anwender und aufgrund der technischen
% und sozialen Verantwortung des Entwicklers,Stand der Technik und ggf. der Forschung,

% Keine Anforderung darf im Folgenden vergessen werden (mindestens Erwähnung in "Weiter- entwicklungsmöglichkeiten").
% • Jedes Feature des konzipierten bzw. realisierten Systems muss auf eine Anforderung zurück- geführt werden.

The audit component implemented in chapter \ref{chap:ac} is to be utilised to offer an audit reporting \gls{ac:gui}. \gls{ac:m8} offer much more features, that can be utilised, thus the \gls{ac:gui} should be expandable to accommodate other use-cases and implementations.

Upstream \gls{ac:iam} authenticators like onelogin are to be supported.

Since Auditors have different backgrounds and technical knowledge the \gls{ac:ux} should be intuitive and well thought out. The following is to be considered:

\begin{itemize}
  \item The same event view musst be ensured to ease dealing with deferent events and allow for a sense of familiarity. For example if a table is used to showcase the event, the table structure is preserved for all types.
  \item lack of events is not an error and musst be clearly represented
\end{itemize}

To ease auditors workflows and external auditing needs audit reports should be exportable and sendable via e-mail in a spread-sheet compatible format like \gls{ac:csv}. Automating these reports should be possible as well.

% alerting and monitoring

% End with a GUI, that the auditor can configure to her/his own requirements

\subsection{Use-Cases}

\begin{table}[H]
  \begin{center}
    \caption{Audit browser derived use-cases}
    \label{tab:abuc}
    \def\arraystretch{1.5}
    \begin{tabularx}{\linewidth}{|l l X |}
      \hline
      \rowcolor{gray!20}
      \textbf{ID} & \textbf{Use-Case} & \textbf{Description}\\
      UC01 & \gls{ac:m8} \gls{ac:gui} & As a user, I want to use \gls{ac:m8} features through an easy to navigate \gls{ac:gui}\\
      UC02 & Onelogin \gls{ac:iam} authentication & As a user, I want to authenticate using my onelogin \gls{ac:iam} account\\
      UC04 & audit-log for date-range report & As an auditor, I want to see all actions taken within a specific date-range\\
      UC05 & audit-log about a user report & As an auditor, I want see all actions taken on a user\\
      UC06 & audit-log of user-actions report & As an auditor, I want see all actions taken by a user\\
      UC07 & audit-log users overview & As an auditor, I want a report of all users at a specific timestamp, tenants they belongs to, and their roles within the system or tenants/clusters\\
      UC08 & \gls{ac:csv} audit-log reports export & As an auditor, I want to export audit-log reports in a \gls{ac:csv} formatted file \gls{ac:gui}\\
      UC09 & Send audit-log reports via e-mail & As an auditor, I want to send audit-log reports via e-mail \gls{ac:gui}\\
      \hline
    \end{tabularx}
  \end{center}
\end{table}

% \subsection{Stakeholders}

\subsection{Architectural Constraints}

\subsubsection{Technical Constraints}

\begin{table}[H]
  \begin{center}
    \caption{Audit browser technical constraints}
    \label{tab:abtc}
    \def\arraystretch{1.5}
    \begin{tabularx}{\linewidth}{|l l X |}
      \hline
      \rowcolor{gray!20}
      \textbf{ID} & \textbf{Constraint} & \textbf{Description}\\
      TC01 & Expandable \gls{ac:gui} & \gls{ac:gui} implementation allow for other \gls{ac:m8} features support\\
      TC02 & Unified event view & Audit-log reports have unified event views\\
      TC03\label{tc:ab03} & Backend & Backend is written in \gls{gl:go}\\
      \hline
    \end{tabularx}
  \end{center}
\end{table}

\subsubsection{Organisational Constraints}

\begin{table}[H]
  \begin{center}
    \caption{Audit component organisational constraints}
    \label{tab:acoc}
    \def\arraystretch{1.5}
    \begin{tabularx}{\linewidth}{|l l X |}
      \hline
      \rowcolor{gray!20}
      \textbf{ID} & \textbf{Constraint} & \textbf{Description}\\
      OC01 & Deadline & implementation musst be finalised before 28.02.2023\\
      \hline
    \end{tabularx}
  \end{center}
\end{table}

\section{System Design}

\subsection{Scope and Context}

\subsubsection{Business Context}

\includenamedsvg{\includesvg[width=\textwidth]}{diagrams/audit_browser/audit_browser_business_context.drawio}{Audit Browser Business Context Diagram}

\subsubsection{Technical Context}

\includenamedsvg{\includesvg[width=\textwidth]}{diagrams/audit_browser/audit_browser_technical_context.drawio}{Audit Browser Business Context Diagram}

% https://youtu.be/XdG0EujccHQ?t=748

\subsection{Solution Strategy}

JS/TS
% https://youtu.be/CAGuhVIOT2c?t=2449
% https://medium.com/zeals-tech-blog/grpc-go-server-web-client-853daf40cdef
% https://www.vinsguru.com/grpc-web-example/
% https://blog.cloudflare.com/moving-k8s-communication-to-grpc/
react
% https://www.youtube.com/watch?v=NFZbTy_B4H0&t=423s
% https://programmingpercy.tech/blog/using-grpc-tls-go-react-no-reverse-proxy/
% https://www.youtube.com/watch?v=XdG0EujccHQ&t=3348s
% https://daily.dev/blog/build-a-chat-app-using-grpc-and-reactjs
% % https://medium.com/@mehran.hrajabi98/grpc-in-front-end-applications-a70a9cea4a43
% https://github.com/mehran-hrajabi/react-grpc-boilerplate
% https://medium.com/alva-labs/building-microapps-with-grpc-web-64b7cdf50313
% https://www.polarsignals.com/blog/posts/2022/06/23/how-we-use-gRPC-to-build-our-frontend/
% https://www.youtube.com/watch?v=NFZbTy_B4H0&t=1944s
Vue.js
% https://medium.com/@itachisasuke/using-grpc-web-vue-js-with-a-golang-backend-76dd9d6fd150
% https://gustavohenrique.net/en/2020/02/grpc-web-with-golang-and-vuejs-an-alternative-to-rest-and-graphql/
% https://torq.io/blog/grpc-web-using-grpc-in-your-front-end-application/
% https://github.com/kostyay/grpc-web-example
Angular
% https://www.youtube.com/watch?v=fvFOBkR6GT8&t=1139s
% https://github.com/search?q=user%3Avishipayyallore+grpc-web&type=code
% https://itnext.io/a-complete-guide-to-grpc-web-with-angular-and-net-c4ae2500bd24
WASM
% https://www.youtube.com/watch?v=swZPL5PjkVU&t=187s
%  youtube.com/watch?v=wUCCrrlzkPU&t=34s
% https://www.youtube.com/watch?v=FBRbdpdK3lI&t=155s


\subsection{Building Block View}

\subsection{Runtime View}

\subsection{Deployment View}

\section{Design Decisions}

Anguler tend to be overkill for small projects and monoskope is not GUI intesive produckt

\subsection{DD01: \gls{ac:api} Gateway}

frontend only talks \gls{ac:rest}

% https://www.theseus.fi/bitstream/handle/10024/501885/Vo_Hoang.pdf?sequence=2

\gls{ac:grpc} is not natively supported in the browser 
% https://drive.google.com/drive/folders/1AOa1kWTnopeOQPy5mVXTJtRt_qqLBnVo
- no way to use HTTP/2
Before we continue, we need to discuss the current limitations of browsers. Browsers do support HTTP2 to get the static files like images, javascript, css etc. But for any XMLHttpRequest/Ajax calls, browsers still use HTTP/1.1. It is a limitation of browsers as of now. Because of this limitation, browser / client side javascript can not directly talk to the backend gRPC server as we normally talk to the backend REST API. 
- no way of attaching gRPC-specific trailers (footers) at the end of every rqueste/response
% https://youtu.be/UV-VnlcpDhU?t=288

Messages passing back and forth are encoded which will be hard to read debug
backend has to put an middleware which translates messages from http to grpc, is this middleware removable?
how is the efficiency doing all this way compared to sending raw http request to backend, any reasonable comparison done so far?

options

- generate REST API
- translate REST to gRPC and vice versa
% Pattern: Backends For Frontends https://samnewman.io/patterns/architectural/bff/


it’s common to use an API gateway to wrap all RPC’s into REST API. Kubernetes dose gRPC internally and REST externally, for lack of options back then?

\header{The problem with REST}

comparison: https://youtu.be/CAGuhVIOT2c?t=1829
% https://blog.cloudflare.com/moving-k8s-communication-to-grpc/

\todo{rest problems}

readability comes with costs. there is no readability in ISO 25010
https://youtu.be/CAGuhVIOT2c?t=841

8 fallacies of distributed systems:

- latency is zero
normally multiple calls are needed a latency add up

- bandwidth is infinite

- transfer cost (the time it take to marshall and unmarshall)

also reason...~\ref{tc:ac03}

research json vs protbuff performance

\header{why stick with gRPC}

proto buffers are much more efficient etc...\todo{TODO}
backword and forward compatibility

Communicating using the synchronous Remote
procedure invocation pattern \citep{richardson2018microservices}

dealing with api changes




\header{Conclusion}

could be an overkill but maintining a REST API on top of gRPC in M8 won't be fun either

From the perspective of using a technology that's a bit bleeding edge, this makes a lot of sense. Putting it on the public edge of your services would definitely be more problematic for load balancers and I imagine it was a struggle just getting basic things working with it vs. the well established patterns one would already have available for REST/HTTP.

\subsection{DD02: Micro Frontends}

\section{Technical Decisions}

Lösungsalternativen sind kritisch zu bewerten und Auswahl zu begründen.

\subsection{TD01: gRPC Web}

https://grpc.io/blog/grpc-web-ga/

gRPC REST gateway implementation.

options:

- gRPC Gateway:
--- server need to know about it
--- -> more maintenance cost
--- -> basically REST API
% https://jbrandhorst.com/post/gopherjs-grpcweb/
Clients don’t know what types are used - the interface is HTTP JSON. This can be somewhat mitigated with the use of swagger generated interfaces, but it’s still not perfect.
The interface being JSON means marshalling and unmarshalling can become a significant part of the latency between the client and the server.
The gRPC-gateway requires specific changes to the proto definitions - it’s not as straightforward as just defining your RPC methods.

- gRPC Web: 
---- only envoy support it
---- still experimental
---- only support unary and server streaming

loadbalancing:

- nginx

- envoy
\gls{ac:m8} comes with \gls{gl:ei} which is built on top of \gls{gl:envoy}
.Net seems have the most adaption and support for web-gRPC but due to the backend being written in \gls{gl:go} (TC03~ref{tc:ab03}) ...

\subsection{TD02: Angular}
% https://github.com/grpc/grpc-web/blob/master/doc/roadmap.md#web-framework-integration

\subsection{Enabling Technologies}

the 8 fallacies of distributed computing

protobuf vs json: https://youtu.be/CAGuhVIOT2c?t=1206

Stand des Projekts und Weiterentwicklungsmöglichkeiten.
• Anhang: Entwicklerdokumentation,Benutzerdokumentation
Elektronischer Anhang: Sources, Projektdateien.