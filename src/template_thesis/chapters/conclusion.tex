% @author Hani Alshikh
%
\chapter{Conclusion}

IT-Auditing is a part of every regulated organisation lifecycle. Not only dose it insure the organisation compliance with regulators requirements it gives the organisation credibility and trustworthiness.  However awaiting periodic audits and hopping for the best outcome is not advisable nor reflect the real world. Auditors have an important role in ensuring confidentiality, integrity and authenticity of various systems.

Supporting Auditors is their mission not only shows teamwork, it is almost always mandatory. Building a compliant system requires a well thought out architecture, that is adequate, efficient, and effective in meeting the organizationâ€™s objectives. Architecting and developing such system, especially the critical ones, requires a good understanding of the requirements. Mainly the non-functional ones, that might not be of a problem at the beginning.

Auditability tend to be one of them. A great care should be takin when handling such decisions. Choosing the right architecture might make or break the system. As discussed in chapter \ref{chap:sadt} auditing might be build as a feature, which delegates the complexity on the developer and comes with its owen risk, or built in by design.

\gls{gl:es} and the event-sourced architecture discussed in chapter \ref{chap:es} tend to be on top of the list, when talking about audit first systems. Systematic, reliable, and trustworthy recording of events is insured. Events can be easily retrieved from the \gls{gl:est} and manipulated as desired. In chapter \ref{chap:ac} a real world use-case of an event-sourced system to manage users authentication and authorization in \gls{ac:k8s} multi-cloud multi-cluster environments was examined and further developed to support a \gls{gl:fintech} organisation in its compliance needs. Being an event-sourced system \gls{ac:m8} offered the event log to implement the missing \gls{gl:ab} as showcased in chapter \ref{chap:ab} that shows how the implemented \gls{gl:ac} can be utilised to easily retrieve various audit logs of users activates and present them in a friendly and intuitive human-readable formats for the auditors of the organisation. This saved the organisation the need to aggregate and process logs on the \gls{ac:k8s} \gls{ac:api} level, which poses its complexity, as it will require various techniques to make sense of the collected logs while insuring context and durability. The \gls{gl:ac} can be taken as is and integrated into another \gls{gl:es} system. The only thing to adapt are the domain specific formatters. Satisfying all audit log specification as described in chapter \ref{chap:adt} make it also possible for all kind of integrations like the case with \gls{gl:adt2} discussed in section \ref{sec:adt2}. 

However one of the auditors request was answering questions like who attempted accessing restricted information or tried deleting business objects, without having any business doing so. Such questions were intentionale skipped, as this is a known limitation of \gls{gl:es} and mainly as it contradict with the the audit log definition [\ref{sec:adtlog}]. And even if required, this limitation must be handled with or without \gls{gl:es} as discussed in section \ref{sec:saes}.

If done correctly (which is the hard part) the implementation of other options compared to \gls{gl:es} shouldn't differ much. Collecting log entries is the same wether they are coming from an \gls{gl:est} or an audit log database. It all comes down to the system requirements. Is audit logging an added feature? and human errors and bugs are not much of a harm and other architectures are of a greater benefit, then there is no extra advantage to use \gls{gl:es} when it comes to audit logging. However having a log of all changes by design and the assurance that the history audited is the actual system history and represent the actual business objects with ability to restore it and test it on a real system without needing to replay commands or script any behavior gives \gls{gl:es} the bigger advantage. 

It goes without saying, that the mentioned is valid for all options and ways of implementing an audit first system. The only thing that differ is the complexity delegation. Either at the beginning, as is the case with \gls{gl:es}, or throughout the entire lifecycle of the system. Other features like \gls{gl:es}'s complete rebuild, temporal query and event replay are much harder to implement if not planned correctly.